{"ast":null,"code":"export var pathFromBezierCurve = function pathFromBezierCurve(cubicBezierCurve) {\n  var initialAxis = cubicBezierCurve.initialAxis,\n      initialControlPoint = cubicBezierCurve.initialControlPoint,\n      endingControlPoint = cubicBezierCurve.endingControlPoint,\n      endingAxis = cubicBezierCurve.endingAxis;\n  return \"\\n\\t\\tM\".concat(initialAxis.x, \" \").concat(initialAxis.y, \"\\n\\t\\tc \").concat(initialControlPoint.x, \" \").concat(initialControlPoint.y, \"\\n\\t\\t\").concat(endingControlPoint.x, \" \").concat(endingControlPoint.y, \"\\n\\t\\t\").concat(endingAxis.x, \" \").concat(endingAxis.y, \"\\n\\t\");\n};\nexport var radiansToDegrees = function radiansToDegrees(radians) {\n  return radians * 180 / Math.PI;\n}; // https://math.stackexchange.com/questions/714378/find-the-angle-that-creating-with-y-axis-in-degrees\n\nexport var calculateAngle = function calculateAngle(x1, y1, x2, y2) {\n  if (x2 >= 0 && y2 >= 0) {\n    return 90;\n  } else if (x2 < 0 && y2 >= 0) {\n    return -90;\n  }\n\n  var dividend = x2 - x1;\n  var divisor = y2 - y1;\n  var quotient = dividend / divisor;\n  return radiansToDegrees(Math.atan(quotient)) * -1;\n};\nexport var getCanvasPosition = function getCanvasPosition(event) {\n  // mouse position on auto-scaling canvas\n  // https://stackoverflow.com/a/10298843/1232793\n  var svg = document.getElementById('aliens-go-home-canvas');\n  var point = svg.createSVGPoint();\n  point.x = event.clientX;\n  point.y = event.clientY;\n\n  var _point$matrixTransfor = point.matrixTransform(svg.getScreenCTM().inverse()),\n      x = _point$matrixTransfor.x,\n      y = _point$matrixTransfor.y;\n\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar degreesToRadian = function degreesToRadian(degrees) {\n  return degrees * Math.PI / 180;\n};\n\nexport var calculateNextPosition = function calculateNextPosition(x, y, angle) {\n  var divisor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 300;\n  var realAngle = angle * -1 + 90;\n  var stepsX = radiansToDegrees(Math.cos(degreesToRadian(realAngle))) / divisor;\n  var stepsY = radiansToDegrees(Math.sin(degreesToRadian(realAngle))) / divisor;\n  return {\n    x: x + stepsX,\n    y: y - stepsY\n  };\n};","map":{"version":3,"sources":["/home/asim/Documents/LUMS/Semester_6/Snake_Game/snake_game/src/utils/formulas.js"],"names":["pathFromBezierCurve","cubicBezierCurve","initialAxis","initialControlPoint","endingControlPoint","endingAxis","x","y","radiansToDegrees","radians","Math","PI","calculateAngle","x1","y1","x2","y2","dividend","divisor","quotient","atan","getCanvasPosition","event","svg","document","getElementById","point","createSVGPoint","clientX","clientY","matrixTransform","getScreenCTM","inverse","degreesToRadian","degrees","calculateNextPosition","angle","realAngle","stepsX","cos","stepsY","sin"],"mappings":"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","sourcesContent":["export const pathFromBezierCurve = (cubicBezierCurve) => {\n\tconst {\n\t\tinitialAxis, initialControlPoint, endingControlPoint, endingAxis\n\t} = cubicBezierCurve;\n\treturn `\n\t\tM${initialAxis.x} ${initialAxis.y}\n\t\tc ${initialControlPoint.x} ${initialControlPoint.y}\n\t\t${endingControlPoint.x} ${endingControlPoint.y}\n\t\t${endingAxis.x} ${endingAxis.y}\n\t`;\n};\n\nexport const radiansToDegrees = radians => ((radians * 180) / Math.PI);\n\n// https://math.stackexchange.com/questions/714378/find-the-angle-that-creating-with-y-axis-in-degrees\nexport const calculateAngle = (x1, y1, x2, y2) => {\n  if (x2 >= 0 && y2 >= 0) {\n    return 90;\n  } else if (x2 < 0 && y2 >= 0) {\n    return -90;\n  }\n\n  const dividend = x2 - x1;\n  const divisor = y2 - y1;\n  const quotient = dividend / divisor;\n  return radiansToDegrees(Math.atan(quotient)) * -1;\n};\n\nexport const getCanvasPosition = (event) => {\n  // mouse position on auto-scaling canvas\n  // https://stackoverflow.com/a/10298843/1232793\n\n  const svg = document.getElementById('aliens-go-home-canvas');\n  const point = svg.createSVGPoint();\n\n  point.x = event.clientX;\n  point.y = event.clientY;\n  const { x, y } = point.matrixTransform(svg.getScreenCTM().inverse());\n  return {x, y};\n};\n\nconst degreesToRadian = degrees => ((degrees * Math.PI) / 180);\n\nexport const calculateNextPosition = (x, y, angle, divisor = 300) => {\n  const realAngle = (angle * -1) + 90;\n  const stepsX = radiansToDegrees(Math.cos(degreesToRadian(realAngle))) / divisor;\n  const stepsY = radiansToDegrees(Math.sin(degreesToRadian(realAngle))) / divisor;\n  return {\n    x: x +stepsX,\n    y: y - stepsY,\n  }\n};"]},"metadata":{},"sourceType":"module"}